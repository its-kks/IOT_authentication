classdef network_manager < handle
    properties
        gs % NMC ground station
        group_change_info
        rgb
        count
        skip % how many times skip generation of new key
        group_key
        nearest_geo
        sc
        ecef
        ind
        times
        ground_station % ground_station
        private_key
        public_key
        IOT_controller
        group_count
    end
    
    methods
        % Constructor
        function obj = network_manager(sc,nameGs,long,lat,rgb,skip,geo_satellites,ind,times,gs_coords)
            obj.gs = groundStation(sc, "Name", nameGs, "Longitude", long, "Latitude", lat);
            obj.group_change_info = [0,0]; % first value indicates addition and second value 
            obj.rgb = rgb;
            obj.count = 0;
            obj.skip = skip;
            obj.group_key = -1;
            obj.gs.MarkerColor = rgb;
            obj.sc = sc;
            obj.ground_station = Ground_station(sc,"GS"+num2str(ind),gs_coords(1),gs_coords(2),[1,1,0],times,ind);
            obj.IOT_controller = -1;
            obj.group_count = 0; % maintains a number for each group

            % AUTHENTICATION PHASE 1: System Initialization Phase
            obj.private_key = Python_random(10000,9999999999);
            obj.public_key = strings(1,2);
            [obj.public_key(1),obj.public_key(2)] = ECC_x_dot_P(obj.private_key);

            geo_min_dis = realmax('double');
            obj.nearest_geo = -1;
            ecef_nm = lla2ecef([lat,long,0]);
            obj.ecef = ecef_nm;
            obj.ind = ind;
            obj.times = times;
            
            % PHASE 2 Ground Station
            obj.registration_phase(obj.ground_station,obj.ground_station.gs.ID);

            % this start time is same as the one mentioned at starting of Simulation_original.m file
            startTime = datetime(2024,2,18,11,23,0);


            % find the nearest geo satellite
            for i = 1:size(geo_satellites,1)
                % ecef coordinates of geo_satellite
                ecef_geo = states(geo_satellites(i),startTime,"CoordinateFrame","ecef");
                curr_dist = distance(ecef_geo,ecef_nm);

                if curr_dist < geo_min_dis
                    geo_min_dis = curr_dist;
                    obj.nearest_geo = i;
                end
            end
            
        end

        % obj is passed implicitly
        function [key,obj] = generate_key(obj, group_matrix_row, leo_satellites,geo_satellites)
            % reset previous values
            
            new_group_key = randi([1,999]);
            obj.group_key = new_group_key;
            obj.increase_group_count();

            disp('********************************************************')
            disp(['Random group key generated by NMC ', obj.gs.Name,' : ',num2str(obj.group_key)]);

            for i=1:size(leo_satellites,1)
                if group_matrix_row(i) > 1

                    % simply pass group key since we are not measuring
                    % group key generation here only authentication is our
                    % concern
                    leo_satellites(i).form_key(new_group_key);

                    % AUTHENTICATION PHASE 2: Registration Phase
                    obj.registration_phase(leo_satellites(i),leo_satellites(i).matlab_sat.ID);

                    % AUTHENTICATION PHASE 3: Proxy Delegation Phase
                    obj.ground_station.authenticate_leo(leo_satellites(i));
                    
                end
            end
        end
        
        function increase_group_count(obj)
            obj.group_count = obj.group_count +  1;
            obj.group_count = mod(obj.group_count,1000);
        end

        function registration_phase(obj,leo_or_gs,id)
            % AUTHENTICATION PHASE 2: Registration Phase
            % For LEO and GroundStation
            rj = Python_random(1000,9999999);
            Kj = strings(1,2);
            [Kj(1),Kj(2)] = ECC_x_dot_P(rj);
            leo_or_gs.public_key_Kj = Kj;
            % NOTE: FOR TAKING HASH VALUE OF POINT FIRST WE ADD X
            % COORDINATE THEN Y COORDINAT
            hash = Hash_bits_to_Z(Kj(1),Kj(2),id);
            leo_or_gs.private_key_sigmaj= string(pyrun([strcat("ans = str(",obj.private_key,"*",hash,"+",rj,")")],"ans"));
            
        end

        function [TID,w_Ui,K_Ui,sigma_Ui,group_count,public_key] = user_registration(obj,ID,IOT)
            r_Ui = Python_random(1000,9999999);
            K_Ui = strings(1,2);
            [K_Ui(1),K_Ui(2)] = ECC_x_dot_P(r_Ui);
            w_Ui = 60; % time registration valid in minutes
            hash = Hash_bits_to_Z(K_Ui(1),K_Ui(2),r_Ui);
            TID = pyrun(strcat("ans = str(int(",hash,") ^ int(",string(ID),"))"),"ans");
            hash = Hash_bits_to_Z(K_Ui(1),K_Ui(2),string(TID),string(w_Ui));
            sigma_Ui = string(pyrun([strcat("ans = str(",obj.private_key,"*",hash,"+",r_Ui,")")],"ans"));
            group_count = obj.group_count;
            public_key = obj.public_key;

            % send response to IOT
            response = strcat(string(TID),string(w_Ui),K_Ui(1),K_Ui(2),sigma_Ui, ...
                string(group_count),string(public_key));

            tic_processing = tic;
            Simulate_Data_Send(response,4);
            processing = toc(tic_processing);

            transmission_time = Transmission_Time(sym(states(IOT.platform,obj.sc.SimulationTime,"CoordinateFrame","ecef")), ...
                obj.ecef,processing);

            obj.times.initial_authentication_transmission(obj.times.initial_authentication_transmission_ind) = ... 
            obj.times.initial_authentication_transmission(obj.times.initial_authentication_transmission_ind) + transmission_time;

        end

        function [TGK] = send_TGK_inter(obj,group_count)
            if group_count ~= obj.group_count
                TGK = "-1";
            else
                TGK = Hash_bits_to_Z(obj.group_key);
            end

            % send TGK to other NMC's Leo
        end
    end
end




