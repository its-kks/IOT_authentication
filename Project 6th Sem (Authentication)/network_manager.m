classdef network_manager < handle
    properties
        gs % NMC ground station
        group_change_info
        rgb
        count
        skip % how many times skip generation of new key
        group_key
        nearest_geo
        sc
        ecef
        ind
        times
        ground_station % ground_station
        private_key
        public_key
        IOT_controller
    end
    
    methods
        % Constructor
        function obj = network_manager(sc,nameGs,long,lat,rgb,skip,geo_satellites,ind,times,gs_coords)
            obj.gs = groundStation(sc, "Name", nameGs, "Longitude", long, "Latitude", lat);
            obj.group_change_info = [0,0]; % first value indicates addition and second value 
            obj.rgb = rgb;
            obj.count = 0;
            obj.skip = skip;
            obj.group_key = -1;
            obj.gs.MarkerColor = rgb;
            obj.sc = sc;
            obj.ground_station = Ground_station(sc,"GS"+num2str(ind),gs_coords(1),gs_coords(2),[1,0,1],times);
            obj.IOT_controller = -1;

            % AUTHENTICATION PHASE 1: System Initialization Phase
            obj.private_key = Python_random(10000,9999999999);
            obj.public_key = strings(1,2);
            [obj.public_key(1),obj.public_key(2)] = ECC_x_dot_P(obj.private_key);

            geo_min_dis = realmax('double');
            obj.nearest_geo = -1;
            ecef_nm = lla2ecef([lat,long,0]);
            obj.ecef = ecef_nm;
            obj.ind = ind;
            obj.times = times;
            
            % PHASE 2 Ground Station
            obj.registration_phase(obj.ground_station,obj.ground_station.gs.ID);

            % this start time is same as the one mentioned at starting of Simulation_original.m file
            startTime = datetime(2024,2,18,11,23,0);


            % find the nearest geo satellite
            for i = 1:size(geo_satellites,1)
                % ecef coordinates of geo_satellite
                ecef_geo = states(geo_satellites(i),startTime,"CoordinateFrame","ecef");
                curr_dist = distance(ecef_geo,ecef_nm);

                if curr_dist < geo_min_dis
                    geo_min_dis = curr_dist;
                    obj.nearest_geo = i;
                end
            end
            
        end

        % obj is passed implicitly
        function [key,obj] = generate_key(obj, group_matrix_row, leo_satellites,geo_satellites)
            % reset previous values
            
            new_group_key = randi([1,999]);
            obj.group_key = new_group_key;

            disp('********************************************************')
            disp(['Random group key generated by NMC ', obj.gs.Name,' : ',num2str(obj.group_key)]);

            for i=1:size(leo_satellites,1)
                if group_matrix_row(i) > 1

                    % simply pass group key since we are not measuring
                    % group key generation here only authentication is our
                    % concern
                    leo_satellites(i).form_key(new_group_key);

                    % AUTHENTICATION PHASE 2: Registration Phase
                    obj.registration_phase(leo_satellites(i),leo_satellites(i).matlab_sat.ID)

                    % AUTHENTICATION PHASE 3: Proxy Delegation Phase
                    obj.ground_station.authenticate_leo(leo_satellites(i));
                    
                end
            end
        end

        function registration_phase(obj,leo_or_gs,id)
            % AUTHENTICATION PHASE 2: Registration Phase
            % For LEO and GroundStation
            rj = Python_random(1000,9999999);
            Kj = strings(1,2);
            [Kj(1),Kj(2)] = ECC_x_dot_P(rj);
            leo_or_gs.public_key_Kj = Kj;
            % NOTE: FOR TAKING HASH VALUE OF POINT FIRST WE ADD X
            % COORDINATE THEN Y COORDINAT
            hash = Hash_bits_to_Z(Kj(1),Kj(2),id);
            leo_or_gs.private_key_sigmaj= string(pyrun([strcat("ans = str(",obj.private_key,"*",hash,"+",rj,")")],"ans"));
            
        end

        function [TID,w_Ui,K_Ui,sigma_Ui] = user_registration(obj,ID)
            r_Ui = Python_random(1000,9999999);
            K_Ui = strings(1,2);
            [K_Ui(1),K_Ui(2)] = ECC_x_dot_P(r_Ui);
            w_Ui = 60; % time registration valid in minutes
            hash = Hash_bits_to_Z(K_Ui(1),K_Ui(2),r_Ui);
            TID = pyrun(strcat("ans = str(int(",hash,") ^ int(",string(ID),"))"),"ans");
            hash = Hash_bits_to_Z(K_Ui(1),K_Ui(2),string(TID),string(w_Ui));
            sigma_Ui = string(pyrun([strcat("ans = str(",obj.private_key,"*",hash,"+",r_Ui,")")],"ans"));

        end
    end
end




